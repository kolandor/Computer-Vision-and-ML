# Импорт библиотек для работы с изображениями и визуализации
import cv2  # OpenCV для работы с изображениями
import numpy as np  # NumPy для численных операций
from matplotlib import pyplot as plt  # Matplotlib для построения графиков
plt.rcParams['figure.figsize'] = [15, 5]  # Настройка размера фигур по умолчанию

# ============================================================================
# ЗАГРУЗКА ИЗОБРАЖЕНИЯ
# ============================================================================

# Загружаем изображение из файла
img = cv2.imread('data/sea.jpg')

# Преобразуем из формата BGR (Blue-Green-Red) в RGB
# OpenCV использует формат BGR, а matplotlib ожидает RGB
img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)

# Отображаем исходное изображение
plt.figure(figsize=(10, 5))
plt.imshow(img)
plt.title('Исходное изображение\n(небалансированное)', fontsize=12, fontweight='bold')
plt.axis('off')
plt.tight_layout()
plt.show()  # Отображаем изображение

# ============================================================================
# МЕТОД "БЕЛОГО ПАТЧА" (WHITE PATCH)
# ============================================================================
# В алгоритме "белого патча" мы выбираем группу пикселей, которые должны быть белыми,
# и масштабируем цветовые каналы изображения на основе этого белого патча.
# Это позволяет исправить цветовой баланс, если известен эталонный белый цвет.

# Определяем координаты пикселя, который должен быть белым (white patch)
row, col = 485, 864 
white = img[row, col, :]  # Значения RGB пикселя белого патча

# Вычисляем коэффициенты масштабирования для каждого канала
# Цель: сделать белый патч действительно белым (255, 255, 255)
coeffs = 255.0/white

# Применяем балансировку белого патча
balanced = np.zeros_like(img, dtype=np.float32)
for channel in range(3):  # По каждому каналу (R, G, B)
    balanced[..., channel] = img[..., channel] * coeffs[channel]

# Белый патч не гарантирует сохранение динамического диапазона,
# поэтому значения, выходящие за пределы [0, 1], нужно обрезать
balanced = balanced/255  # Нормализуем в диапазон [0, 1]
balanced[balanced > 1] = 1  # Обрезаем значения выше 1

# Сравниваем исходное и сбалансированное изображение
plt.figure(figsize=(12, 5))
plt.subplot(121)
plt.imshow(img)
plt.title('Исходное изображение\n(небалансированное)', fontsize=11, fontweight='bold')
plt.axis('off')

plt.subplot(122)
plt.imshow(balanced)
plt.title('Балансировка белого патча\n(исправление цветового баланса)', 
          fontsize=11, fontweight='bold')
plt.axis('off')

plt.tight_layout()
plt.show()  # Отображаем изображение

# ============================================================================
# МЕТОД "СЕРЫЙ МИР" (GRAY WORLD)
# ============================================================================
# Этот алгоритм предполагает, что в среднем сцена имеет серый цвет.
# Предполагается, что средние значения всех цветовых каналов должны быть равны,
# что соответствует нейтральному серому цвету.

# Загружаем изображение заново
img = cv2.imread('data/sea.jpg')
img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)

# Вычисляем средние значения для всех трёх цветовых каналов (красный, зелёный, синий)
mean_r = img[..., 0].mean()
mean_g = img[..., 1].mean()
mean_b = img[..., 2].mean()

# Вычисляем коэффициенты kr, kg, kb
# Примечание: нужно вычислить 3 коэффициента, но у нас только 2 уравнения.
# Поэтому нужно сделать предположение: зафиксировать значение одного из коэффициентов
# и вычислить оставшиеся два.
# Подсказка: можно зафиксировать коэффициент самого яркого канала равным 1.

# Находим среднее из всех средних значений каналов (целевое значение для серого)
mean_gray = (mean_r + mean_g + mean_b) / 3.0

# Вычисляем коэффициенты, чтобы привести средние значения каналов к среднему серому
coeffs = np.array([mean_gray / mean_r, mean_gray / mean_g, mean_gray / mean_b])

# Применяем балансировку "серый мир"
balanced = np.zeros_like(img, dtype=np.float32)
for channel in range(3):  # По каждому каналу (R, G, B)
    balanced[..., channel] = img[..., channel] * coeffs[channel]

# Балансировка не гарантирует сохранение динамического диапазона,
# поэтому значения, выходящие за пределы [0, 255], нужно обрезать
balanced = balanced/255  # Нормализуем в диапазон [0, 1]
balanced[balanced > 1] = 1  # Обрезаем значения выше 1

# Сравниваем исходное и сбалансированное изображение
plt.figure(figsize=(12, 5))
plt.subplot(121)
plt.imshow(img)
plt.title('Исходное изображение\n(небалансированное)', fontsize=11, fontweight='bold')
plt.axis('off')

plt.subplot(122)
plt.imshow(balanced)
plt.title('Балансировка "серый мир"\n(выравнивание средних значений каналов)', 
          fontsize=11, fontweight='bold')
plt.axis('off')

plt.tight_layout()
plt.show()  # Отображаем изображение

# ============================================================================
# МЕТОД "МАСШТАБИРОВАНИЕ ПО МАКСИМУМУ" (SCALE-BY-MAX)
# ============================================================================
# Это простой алгоритм, который масштабирует каждый цветовой канал на основе
# его максимального значения. Каждый канал масштабируется так, чтобы его максимум
# стал равным 255.
# 
# Внимание: этот метод чувствителен к шуму и насыщению (saturation),
# так как один яркий пиксель может влиять на масштабирование всего канала.

# Загружаем изображение заново
img = cv2.imread('data/sea.jpg')
img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)

# Вычисляем максимальные значения для всех трёх цветовых каналов
max_r = img[..., 0].max()  # Максимум красного канала
max_g = img[..., 1].max()  # Максимум зелёного канала
max_b = img[..., 2].max()  # Максимум синего канала

# Применяем масштабирование по максимуму
# Каждый канал масштабируется так, чтобы его максимальное значение стало 255
balanced = np.zeros_like(img, dtype=np.float32)
balanced[..., 0] = img[..., 0] * (255.0 / max_r)  # Масштабируем красный канал
balanced[..., 1] = img[..., 1] * (255.0 / max_g)  # Масштабируем зелёный канал
balanced[..., 2] = img[..., 2] * (255.0 / max_b)  # Масштабируем синий канал

# Масштабирование по максимуму не гарантирует сохранение динамического диапазона,
# поэтому значения, выходящие за пределы [0, 255], нужно обрезать
balanced = balanced/255  # Нормализуем в диапазон [0, 1]
balanced[balanced > 1] = 1  # Обрезаем значения выше 1

# Сравниваем исходное и сбалансированное изображение
plt.figure(figsize=(12, 5))
plt.subplot(121)
plt.imshow(img)
plt.title('Исходное изображение\n(небалансированное)', fontsize=11, fontweight='bold')
plt.axis('off')

plt.subplot(122)
plt.imshow(balanced)
plt.title('Масштабирование по максимуму\n(каждый канал масштабирован до максимума 255)', 
          fontsize=11, fontweight='bold')
plt.axis('off')

plt.tight_layout()
plt.show()  # Отображаем изображение